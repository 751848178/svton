---
name: prd-document-generator
description: PRD 文档生成器 - 生成产品需求文档、技术方案、API 文档
triggers:
  - PRD
  - 需求文档
  - 产品文档
  - 技术方案
  - 方案设计
  - API 文档
  - 接口文档
  - 需求
  - 设计文档
resources:
  - type: article
    url: https://www.productplan.com/glossary/product-requirements-document/
    description: PRD 最佳实践
---

# PRD 文档生成器

## 目标

帮助用户快速生成结构化的产品需求文档（PRD）或技术方案文档，涵盖需求背景、功能设计、技术方案、验收标准等核心内容。

## 适用场景

- **新功能开发**：产品新功能的需求文档
- **技术方案设计**：架构设计、重构方案、技术选型
- **API 接口文档**：RESTful API、GraphQL、RPC 接口
- **系统优化**：性能优化、安全加固、稳定性提升
- **问题修复**：Bug 修复方案、技术债务清理
- **第三方集成**：支付、登录、消息推送等集成方案

## 文档结构

### 标准 PRD 结构


```markdown
# [功能/项目名称]

## 1. 需求背景
- 为什么要做这个功能？
- 解决什么问题？
- 预期收益是什么？

## 2. 目标用户
- 谁会使用这个功能？
- 用户画像和使用场景

## 3. 功能需求

### 3.1 核心功能
- 功能点 1
- 功能点 2

### 3.2 边界条件
- 什么情况下不支持？
- 有哪些限制？

### 3.3 异常处理
- 错误提示
- 降级方案

## 4. 非功能需求
- 性能要求
- 安全要求
- 可用性要求
- 兼容性要求

## 5. 技术方案

### 5.1 架构设计
- 系统架构图
- 模块划分

### 5.2 技术选型
- 使用的技术栈
- 选型理由

### 5.3 关键流程
- 核心业务流程
- 异常处理流程

## 6. 数据模型
- 数据库表设计
- 数据字典

## 7. 接口设计
- API 列表
- 请求/响应示例

## 8. 验收标准
- 功能验收
- 性能验收
- 安全验收

## 9. 风险评估
- 技术风险
- 业务风险
- 应对措施

## 10. 排期计划
- 开发排期
- 测试排期
- 上线时间
```

### 技术方案文档结构


```markdown
# [技术方案名称]

## 1. 方案背景
- 现状问题
- 优化目标

## 2. 方案对比

### 方案 A
- 优势
- 劣势
- 适用场景

### 方案 B
- 优势
- 劣势
- 适用场景

### 推荐方案
- 选择理由
- 风险评估

## 3. 详细设计

### 3.1 架构设计
- 整体架构
- 模块划分
- 技术栈

### 3.2 核心流程
- 流程图
- 关键步骤说明

### 3.3 数据设计
- 数据模型
- 存储方案

## 4. 实施计划

### 4.1 开发计划
- 阶段划分
- 时间安排

### 4.2 测试计划
- 测试策略
- 测试用例

### 4.3 上线计划
- 灰度方案
- 回滚方案

## 5. 监控与运维
- 监控指标
- 告警规则
- 应急预案
```

## 分析步骤

### 1. 信息收集

从用户描述或代码中提取：
- **需求来源**：用户反馈、数据分析、竞品分析、战略规划
- **核心诉求**：要解决的核心问题
- **约束条件**：时间、资源、技术限制
- **成功标准**：如何衡量成功

### 2. 需求分析

- **用户价值**：对用户有什么好处
- **商业价值**：对业务有什么帮助
- **技术可行性**：能否实现，成本多高
- **优先级判断**：P0/P1/P2

### 3. 方案设计

- **功能拆解**：分解为可实现的功能点
- **技术选型**：选择合适的技术方案
- **风险识别**：找出潜在风险和应对措施
- **资源评估**：需要多少人力和时间

### 4. 文档输出

- **结构清晰**：使用标准模板
- **内容完整**：覆盖所有必要信息
- **表达准确**：避免歧义
- **可执行**：开发人员能直接上手

## 最佳实践

### 需求描述

- **用户故事格式**：作为[角色]，我想要[功能]，以便[价值]
- **验收标准**：Given-When-Then 格式
- **优先级标注**：Must Have / Should Have / Nice to Have

### 技术方案

- **方案对比**：至少列出 2-3 个备选方案
- **架构图**：使用 Mermaid 或其他工具绘制
- **代码示例**：关键逻辑提供伪代码或示例
- **性能指标**：明确 QPS、响应时间、并发数等

### 接口设计

- **RESTful 规范**：遵循 REST 最佳实践
- **请求示例**：提供完整的 curl 或代码示例
- **错误码**：定义清晰的错误码体系
- **版本管理**：考虑 API 版本演进

### 风险管理

- **技术风险**：新技术、复杂度、依赖
- **业务风险**：需求变更、资源不足
- **时间风险**：排期延误、依赖延期
- **应对措施**：每个风险都要有应对方案

## 常见模板

### 模板 1：功能需求 PRD


适用于产品功能开发，侧重用户价值和交互设计。

```markdown
# 用户积分系统

## 1. 需求背景

### 1.1 问题描述
当前平台缺少用户激励机制，用户活跃度和留存率较低。通过积分系统可以：
- 提升用户活跃度（目标提升 30%）
- 增加用户粘性（目标留存率提升 20%）
- 引导用户完成关键行为（如完善资料、邀请好友）

### 1.2 数据支持
- 竞品分析：80% 的同类产品都有积分体系
- 用户调研：65% 的用户表示积分奖励会提升使用意愿
- A/B 测试：小范围测试显示积分功能可提升 25% 的活跃度

## 2. 目标用户

### 2.1 主要用户
- 普通用户：通过日常行为获取积分，兑换权益
- VIP 用户：获得更高的积分倍率和专属兑换权益

### 2.2 使用场景
- 场景 1：用户完成任务后自动获得积分
- 场景 2：用户在积分商城兑换商品或优惠券
- 场景 3：用户查看积分明细和有效期

## 3. 功能需求

### 3.1 核心功能

#### 3.1.1 积分获取
- 签到：每日签到获得 10 积分，连续签到有额外奖励
- 任务：完成指定任务获得积分（如完善资料 50 分，首次购买 100 分）
- 消费：每消费 1 元获得 1 积分
- 邀请：成功邀请好友注册获得 200 积分

#### 3.1.2 积分消费
- 商品兑换：使用积分兑换实物商品
- 优惠券兑换：使用积分兑换优惠券
- 会员权益：使用积分兑换 VIP 会员时长

#### 3.1.3 积分管理
- 积分余额：显示当前可用积分
- 积分明细：显示获取和消费记录
- 积分有效期：积分有效期 1 年，到期自动清零

### 3.2 边界条件
- 积分不可转赠给其他用户
- 积分不可提现
- 兑换的商品不支持退货退积分
- 单笔订单最多使用 50% 积分抵扣

### 3.3 异常处理
- 积分不足：提示用户积分不足，引导完成任务
- 商品库存不足：提示商品已兑完，推荐其他商品
- 积分过期：提前 7 天推送提醒通知

## 4. 非功能需求

### 4.1 性能要求
- 积分查询响应时间 < 200ms
- 积分变更实时生效（< 1s）
- 支持 10000 QPS 的并发查询

### 4.2 安全要求
- 防止积分刷单：同一用户同一任务每天只能完成一次
- 防止恶意兑换：兑换需要二次确认
- 积分变更日志：所有积分变更都要记录日志

### 4.3 可用性要求
- 系统可用性 99.9%
- 积分计算错误率 < 0.01%

## 5. 交互设计

### 5.1 页面结构
- 积分首页：显示积分余额、任务列表、兑换入口
- 任务中心：显示所有可完成的任务
- 积分商城：显示可兑换的商品
- 积分明细：显示积分收支记录

### 5.2 关键交互
- 签到：点击签到按钮，弹窗显示获得积分数，连续签到显示进度
- 兑换：选择商品，确认兑换，扣除积分，显示兑换成功

## 6. 技术方案（简要）

### 6.1 数据模型
- 用户积分表：user_id, balance, total_earned, total_spent
- 积分明细表：user_id, amount, type, reason, created_at
- 积分商品表：id, name, price, stock, status

### 6.2 关键流程
- 积分发放：任务完成 → 触发积分发放 → 更新余额 → 记录明细 → 推送通知
- 积分兑换：选择商品 → 检查库存和积分 → 扣除积分 → 创建订单 → 发货

## 7. 验收标准

### 7.1 功能验收
- [ ] 用户可以通过签到、任务、消费获得积分
- [ ] 用户可以使用积分兑换商品和优惠券
- [ ] 用户可以查看积分余额和明细
- [ ] 积分到期前 7 天会收到提醒

### 7.2 性能验收
- [ ] 积分查询响应时间 < 200ms
- [ ] 支持 10000 QPS 并发

### 7.3 安全验收
- [ ] 无法通过刷单获取积分
- [ ] 所有积分变更都有日志记录

## 8. 风险评估

### 8.1 技术风险
- **风险**：高并发下积分计算可能出现不一致
- **应对**：使用 Redis 分布式锁 + 数据库事务保证一致性

### 8.2 业务风险
- **风险**：积分成本过高，影响利润
- **应对**：设置积分获取上限，定期评估积分价值

### 8.3 运营风险
- **风险**：用户对积分商品不感兴趣
- **应对**：定期更新商品，收集用户反馈

## 9. 排期计划

- 需求评审：1 天
- 设计评审：1 天
- 后端开发：5 天
- 前端开发：5 天
- 联调测试：2 天
- 测试验收：3 天
- 灰度发布：2 天
- 全量上线：1 天

**总计：20 个工作日**
```

### 模板 2：技术方案文档


适用于技术优化、架构升级等技术驱动的项目。

```markdown
# 订单系统分库分表方案

## 1. 方案背景

### 1.1 现状问题
- 订单表数据量已达 5000 万，单表查询性能下降
- 高峰期数据库 CPU 使用率达 90%，响应时间超过 2s
- 数据库磁盘空间不足，需要频繁扩容

### 1.2 优化目标
- 查询响应时间降低到 500ms 以内
- 支持未来 3 年的业务增长（预计 5 亿订单）
- 提升系统可用性，避免单点故障

## 2. 方案对比

### 方案 A：垂直分库
**优势**：
- 实施简单，改动小
- 不同业务独立数据库，互不影响

**劣势**：
- 无法解决单表数据量过大的问题
- 扩展性有限

**适用场景**：数据量不大，但业务模块多

### 方案 B：水平分表（单库）
**优势**：
- 解决单表数据量问题
- 实施相对简单

**劣势**：
- 数据库连接数压力大
- 无法解决数据库 CPU 瓶颈

**适用场景**：数据量大，但 QPS 不高

### 方案 C：水平分库分表（推荐）
**优势**：
- 同时解决数据量和并发问题
- 扩展性好，可以持续扩容
- 提升可用性，避免单点故障

**劣势**：
- 实施复杂度高
- 需要处理跨库查询、分布式事务

**适用场景**：数据量大且 QPS 高

### 推荐方案：方案 C
**选择理由**：
- 当前订单表数据量和 QPS 都很高，需要同时优化
- 业务还在快速增长，需要良好的扩展性
- 团队有分库分表经验，技术风险可控

## 3. 详细设计

### 3.1 分片策略

#### 分库分表规则
- **分库数量**：4 个库（db_0, db_1, db_2, db_3）
- **每库分表数量**：256 个表（order_000 ~ order_255）
- **总分片数**：1024 个分片
- **分片键**：user_id（用户维度查询最多）
- **分片算法**：user_id % 1024

#### 路由规则
```
库编号 = (user_id % 1024) / 256
表编号 = (user_id % 1024) % 256
```

#### 示例
```
user_id = 123456
分片号 = 123456 % 1024 = 640
库编号 = 640 / 256 = 2 (db_2)
表编号 = 640 % 256 = 128 (order_128)
最终路由：db_2.order_128
```

### 3.2 架构设计

```mermaid
flowchart TD
    App[应用层] --> Proxy[ShardingSphere-Proxy]
    Proxy --> DB0[(db_0<br/>256 tables)]
    Proxy --> DB1[(db_1<br/>256 tables)]
    Proxy --> DB2[(db_2<br/>256 tables)]
    Proxy --> DB3[(db_3<br/>256 tables)]
```

### 3.3 技术选型

**分库分表中间件**：ShardingSphere-Proxy
- 支持多种数据库
- 支持读写分离
- 支持分布式事务
- 社区活跃，文档完善

**数据迁移工具**：自研 + DataX
- 自研工具：处理业务逻辑
- DataX：批量数据迁移

### 3.4 数据迁移方案

#### 迁移步骤
1. **双写阶段**（1 周）
   - 新订单同时写入旧库和新库
   - 读取仍从旧库

2. **数据补齐**（2 周）
   - 使用 DataX 迁移历史数据
   - 按 user_id 分批迁移，每批 10 万条
   - 迁移完成后校验数据一致性

3. **读写切换**（1 周）
   - 灰度切换读流量到新库
   - 观察 1 周，无问题后全量切换
   - 停止双写，只写新库

4. **清理旧库**（1 周）
   - 保留旧库数据 1 个月
   - 确认无问题后删除旧库

### 3.5 查询优化

#### 单分片查询（最优）
```sql
-- 根据 user_id 查询，直接路由到单个分片
SELECT * FROM order WHERE user_id = 123456;
```

#### 跨分片查询（需优化）
```sql
-- 根据 order_id 查询，需要扫描所有分片
SELECT * FROM order WHERE order_id = 'xxx';

-- 优化方案：建立 order_id -> user_id 的映射表
-- 先查映射表获取 user_id，再查订单表
```

#### 聚合查询（避免）
```sql
-- 跨分片聚合，性能差
SELECT COUNT(*) FROM order WHERE status = 'paid';

-- 优化方案：使用数据仓库或 ES 做统计分析
```

### 3.6 分布式事务

**场景**：订单创建 + 库存扣减（跨库）

**方案**：使用 Seata AT 模式
- 自动管理分布式事务
- 对业务代码侵入小
- 性能损耗可接受（约 20%）

**示例**：
```java
@GlobalTransactional
public void createOrder(Order order) {
    // 1. 创建订单（订单库）
    orderMapper.insert(order);
    
    // 2. 扣减库存（商品库）
    productService.decreaseStock(order.getProductId(), order.getQuantity());
    
    // 3. 扣减余额（账户库）
    accountService.decreaseBalance(order.getUserId(), order.getAmount());
}
```

## 4. 实施计划

### 4.1 开发计划

**第 1 周：环境准备**
- 搭建 ShardingSphere-Proxy 环境
- 创建分库分表结构
- 开发数据迁移工具

**第 2-3 周：代码改造**
- 改造 DAO 层，支持分片
- 改造查询逻辑，优化跨分片查询
- 单元测试和集成测试

**第 4 周：数据迁移**
- 开启双写
- 迁移历史数据
- 数据校验

**第 5 周：灰度上线**
- 灰度切换读流量
- 监控性能和错误
- 全量切换

### 4.2 测试计划

**功能测试**：
- 订单 CRUD 功能正常
- 跨分片查询正确
- 分布式事务正常

**性能测试**：
- 单分片查询 < 100ms
- 跨分片查询 < 500ms
- 支持 10000 QPS

**压力测试**：
- 模拟双 11 流量（50000 QPS）
- 观察数据库 CPU、内存、连接数

### 4.3 上线计划

**灰度方案**：
- 第 1 天：1% 流量
- 第 2 天：10% 流量
- 第 3 天：50% 流量
- 第 4 天：100% 流量

**回滚方案**：
- 保留旧库数据
- 准备回滚脚本
- 5 分钟内可回滚

## 5. 监控与运维

### 5.1 监控指标

**性能指标**：
- 查询响应时间（P50、P95、P99）
- QPS 和 TPS
- 慢查询数量

**资源指标**：
- 数据库 CPU 使用率
- 数据库内存使用率
- 数据库连接数

**业务指标**：
- 订单创建成功率
- 数据一致性（定时校验）

### 5.2 告警规则

- 查询响应时间 P99 > 1s：告警
- 数据库 CPU > 80%：告警
- 订单创建失败率 > 1%：告警
- 数据不一致：紧急告警

### 5.3 应急预案

**场景 1：某个分片故障**
- 影响：该分片的用户无法查询订单
- 应对：切换到从库，或临时降级

**场景 2：ShardingSphere-Proxy 故障**
- 影响：所有订单查询失败
- 应对：重启 Proxy，或切换到备用 Proxy

**场景 3：数据不一致**
- 影响：用户看到错误的订单信息
- 应对：停止写入，人工修复数据

## 6. 风险评估

### 6.1 技术风险

**风险 1：数据迁移失败**
- 概率：中
- 影响：高
- 应对：分批迁移，每批校验，失败可重试

**风险 2：跨分片查询性能差**
- 概率：高
- 影响：中
- 应对：优化查询逻辑，使用 ES 做辅助查询

**风险 3：分布式事务失败**
- 概率：低
- 影响：高
- 应对：充分测试，准备补偿机制

### 6.2 业务风险

**风险 1：迁移期间影响业务**
- 概率：中
- 影响：高
- 应对：选择低峰期迁移，准备回滚方案

**风险 2：成本增加**
- 概率：高
- 影响：中
- 应对：评估成本收益，分阶段扩容

## 7. 成本评估

### 7.1 硬件成本
- 数据库服务器：4 台 * 2 万/年 = 8 万/年
- ShardingSphere-Proxy：2 台 * 1 万/年 = 2 万/年
- **总计：10 万/年**

### 7.2 人力成本
- 开发：2 人 * 5 周 = 10 人周
- 测试：1 人 * 2 周 = 2 人周
- DBA：1 人 * 2 周 = 2 人周
- **总计：14 人周**

### 7.3 收益评估
- 查询性能提升 75%（2s → 500ms）
- 支持未来 3 年业务增长
- 避免因性能问题导致的用户流失

**ROI**：预计 1 年内收回成本
```

### 模板 3：API 接口文档


适用于前后端接口对接，需要详细的请求响应示例。

```markdown
# 用户管理 API 文档

## 1. 接口概述

### 1.1 基本信息
- **Base URL**：`https://api.example.com/v1`
- **认证方式**：Bearer Token（JWT）
- **请求格式**：JSON
- **响应格式**：JSON
- **字符编码**：UTF-8

### 1.2 通用响应格式

**成功响应**：
```json
{
  "code": 0,
  "message": "success",
  "data": { ... }
}
```

**错误响应**：
```json
{
  "code": 1001,
  "message": "参数错误",
  "data": null
}
```

### 1.3 错误码

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| 0 | 成功 | - |
| 1001 | 参数错误 | 检查请求参数 |
| 1002 | 认证失败 | 重新登录 |
| 1003 | 权限不足 | 联系管理员 |
| 1004 | 资源不存在 | 检查资源 ID |
| 1005 | 资源已存在 | 避免重复创建 |
| 5000 | 服务器错误 | 稍后重试 |

## 2. 接口列表

### 2.1 用户注册

**接口**：`POST /users/register`

**描述**：用户通过手机号和验证码注册账号

**请求头**：
```
Content-Type: application/json
```

**请求参数**：
| 参数 | 类型 | 必填 | 说明 | 示例 |
|------|------|------|------|------|
| phone | string | 是 | 手机号 | "13800138000" |
| code | string | 是 | 验证码 | "123456" |
| password | string | 是 | 密码（8-20位） | "password123" |
| nickname | string | 否 | 昵称 | "张三" |

**请求示例**：
```bash
curl -X POST https://api.example.com/v1/users/register \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "13800138000",
    "code": "123456",
    "password": "password123",
    "nickname": "张三"
  }'
```

**响应示例**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "userId": "123456",
    "phone": "13800138000",
    "nickname": "张三",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 604800
  }
}
```

**错误示例**：
```json
{
  "code": 1001,
  "message": "验证码错误",
  "data": null
}
```

---

### 2.2 用户登录

**接口**：`POST /users/login`

**描述**：用户通过手机号和密码登录

**请求参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| phone | string | 是 | 手机号 |
| password | string | 是 | 密码 |

**请求示例**：
```bash
curl -X POST https://api.example.com/v1/users/login \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "13800138000",
    "password": "password123"
  }'
```

**响应示例**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "userId": "123456",
    "phone": "13800138000",
    "nickname": "张三",
    "avatar": "https://cdn.example.com/avatar/123456.jpg",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 604800
  }
}
```

---

### 2.3 获取用户信息

**接口**：`GET /users/:userId`

**描述**：获取指定用户的详细信息

**请求头**：
```
Authorization: Bearer {token}
```

**路径参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| userId | string | 是 | 用户 ID |

**请求示例**：
```bash
curl -X GET https://api.example.com/v1/users/123456 \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**响应示例**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "userId": "123456",
    "phone": "13800138000",
    "nickname": "张三",
    "avatar": "https://cdn.example.com/avatar/123456.jpg",
    "gender": 1,
    "birthday": "1990-01-01",
    "email": "zhangsan@example.com",
    "createdAt": "2024-01-01T00:00:00Z",
    "updatedAt": "2024-01-10T00:00:00Z"
  }
}
```

---

### 2.4 更新用户信息

**接口**：`PUT /users/:userId`

**描述**：更新用户的个人信息

**请求头**：
```
Authorization: Bearer {token}
Content-Type: application/json
```

**路径参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| userId | string | 是 | 用户 ID |

**请求参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| nickname | string | 否 | 昵称 |
| avatar | string | 否 | 头像 URL |
| gender | number | 否 | 性别（0:未知 1:男 2:女） |
| birthday | string | 否 | 生日（YYYY-MM-DD） |
| email | string | 否 | 邮箱 |

**请求示例**：
```bash
curl -X PUT https://api.example.com/v1/users/123456 \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -H "Content-Type: application/json" \
  -d '{
    "nickname": "李四",
    "gender": 1,
    "birthday": "1990-01-01"
  }'
```

**响应示例**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "userId": "123456",
    "nickname": "李四",
    "gender": 1,
    "birthday": "1990-01-01",
    "updatedAt": "2024-01-15T00:00:00Z"
  }
}
```

---

### 2.5 用户列表（分页）

**接口**：`GET /users`

**描述**：获取用户列表，支持分页和筛选

**请求头**：
```
Authorization: Bearer {token}
```

**查询参数**：
| 参数 | 类型 | 必填 | 说明 | 默认值 |
|------|------|------|------|--------|
| page | number | 否 | 页码（从 1 开始） | 1 |
| pageSize | number | 否 | 每页数量 | 20 |
| keyword | string | 否 | 搜索关键词（昵称/手机号） | - |
| gender | number | 否 | 性别筛选 | - |
| sortBy | string | 否 | 排序字段 | createdAt |
| sortOrder | string | 否 | 排序方式（asc/desc） | desc |

**请求示例**：
```bash
curl -X GET "https://api.example.com/v1/users?page=1&pageSize=20&keyword=张" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**响应示例**：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "list": [
      {
        "userId": "123456",
        "phone": "13800138000",
        "nickname": "张三",
        "avatar": "https://cdn.example.com/avatar/123456.jpg",
        "gender": 1,
        "createdAt": "2024-01-01T00:00:00Z"
      },
      {
        "userId": "123457",
        "phone": "13800138001",
        "nickname": "张四",
        "avatar": "https://cdn.example.com/avatar/123457.jpg",
        "gender": 2,
        "createdAt": "2024-01-02T00:00:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

## 3. 数据模型

### 3.1 User（用户）

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| userId | string | 用户 ID | "123456" |
| phone | string | 手机号 | "13800138000" |
| nickname | string | 昵称 | "张三" |
| avatar | string | 头像 URL | "https://..." |
| gender | number | 性别（0:未知 1:男 2:女） | 1 |
| birthday | string | 生日 | "1990-01-01" |
| email | string | 邮箱 | "user@example.com" |
| status | number | 状态（0:禁用 1:正常） | 1 |
| createdAt | string | 创建时间（ISO 8601） | "2024-01-01T00:00:00Z" |
| updatedAt | string | 更新时间（ISO 8601） | "2024-01-10T00:00:00Z" |

## 4. 认证说明

### 4.1 获取 Token
通过登录或注册接口获取 Token

### 4.2 使用 Token
在请求头中添加：
```
Authorization: Bearer {token}
```

### 4.3 Token 过期
- Token 有效期：7 天
- 过期后需要重新登录
- 错误码：1002

### 4.4 刷新 Token
```bash
POST /users/refresh-token
Authorization: Bearer {old_token}
```

## 5. 限流说明

- 单个 IP：100 次/分钟
- 单个用户：1000 次/小时
- 超过限制返回 429 状态码

## 6. 测试环境

- **测试地址**：`https://api-test.example.com/v1`
- **测试账号**：phone: 13800138000, password: test123
- **测试 Token**：有效期 30 天

## 7. 变更日志

### v1.1.0（2024-01-15）
- 新增：用户列表接口支持关键词搜索
- 优化：注册接口响应时间从 500ms 降低到 200ms
- 修复：更新用户信息时邮箱格式校验问题

### v1.0.0（2024-01-01）
- 初始版本发布
```

## 输出格式

每次生成 PRD 时，按以下格式输出：

### 1. 文档概述
用 2-3 句话说明这个文档的主题和目标。

### 2. 完整 PRD 内容
按照选定的模板结构输出完整内容。

### 3. 关键决策说明
列出 3-5 个重要的设计决策及其理由。

### 4. 后续行动项
列出接下来需要做的事情（如评审、开发、测试等）。

## 使用指南

### 如何请求生成 PRD

**方式 1：描述需求**
```
"帮我写一个用户积分系统的 PRD"
```

**方式 2：提供大纲**
```
"根据这个功能列表生成 PRD：[粘贴列表]"
```

**方式 3：指定模板**
```
"用技术方案模板写一个 Redis 缓存优化方案"
```

### 如何优化已有 PRD

```
"这个 PRD 缺少风险评估，帮我补充"
"增加 API 接口设计部分"
"简化技术方案，只保留核心内容"
```

## 注意事项

1. **明确目标**：PRD 的首要任务是说清楚「做什么」和「为什么做」
2. **量化指标**：尽量用数据说话，避免模糊的描述
3. **考虑边界**：明确什么不做，避免范围蔓延
4. **可执行性**：开发人员看完能直接上手，不需要反复确认
5. **及时更新**：需求变更时同步更新文档
6. **版本管理**：重大变更时保留历史版本

## 进阶技巧

### 使用用户故事

```
作为【角色】
我想要【功能】
以便【价值】

验收标准：
- Given【前置条件】
- When【操作】
- Then【预期结果】
```

### 使用决策记录（ADR）

```markdown
## 决策：选择 Redis 作为缓存方案

### 背景
需要缓存热点数据，降低数据库压力

### 决策
使用 Redis 而不是 Memcached

### 理由
- Redis 支持更丰富的数据结构
- Redis 支持持久化
- 团队有 Redis 使用经验

### 后果
- 需要额外的 Redis 服务器成本
- 需要学习 Redis 的最佳实践
```

### 使用 RFC 格式

对于重大技术决策，可以使用 RFC（Request for Comments）格式：
- 背景和动机
- 提案详情
- 备选方案
- 未解决的问题
- 参考资料

## 相关工具

- **协作工具**：Notion、飞书文档、语雀
- **原型工具**：Figma、Sketch、Axure
- **流程图**：使用 diagram-flowchart.md Skill
- **架构图**：使用 diagram-mindmap.md Skill
- **版本管理**：Git（将 PRD 纳入版本控制）
